<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Mammobits Arcade — Pac-Mammoth</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --tile: 20px; }
    html, body { margin:0; background:#000; color:#fff; font-family:Arial, Helvetica, sans-serif; }
    #ui { position:fixed; inset:0 0 auto 0; display:flex; gap:16px; padding:10px 14px; align-items:center; z-index:2; }
    #score { font-weight:700; }
    #canvas { display:block; margin:48px auto 20px; background:#000; }
    button { background:#10b981; color:#00100a; border:0; padding:6px 10px; border-radius:6px; cursor:pointer; }
    button:active { transform:translateY(1px); }
    a { color:#35f; }
  </style>
</head>
<body>
  <div id="ui">
    <div id="score">Score: 0</div>
    <div id="lives">Lives: 3</div>
    <button id="toggleAudio">Music: ON</button>
  </div>

  <!-- 400x400 playfield = 20x20 tiles at 20px -->
  <canvas id="canvas" width="400" height="400"></canvas>
  <audio id="bgm" src="backgroundmusic.mp3" loop preload="auto"></audio>

  <script>
  // -------------------- Prevent page from scrolling during play --------------------
  window.addEventListener(
    "keydown",
    (e) => {
      const block = [
        "ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight",
        " ", "Spacebar", "PageUp", "PageDown"
      ];
      if (block.includes(e.key)) e.preventDefault();
    },
    { capture: true }
  );

  // -------------------- Image loader with fallback to *_clean.png --------------------
  function loadImageTry(baseName) {
    return new Promise((resolve) => {
      const clean = new Image();
      const original = new Image();

      clean.onload = () => resolve(clean);
      clean.onerror = () => {
        original.onload = () => resolve(original);
        original.src = baseName;
      };
      clean.src = baseName.replace(".png", "_clean.png");
    });
  }

  async function loadSprites() {
    const mammoth = {
      up:    await loadImageTry("mammoth_up.png"),
      down:  await loadImageTry("mammoth_down.png"),
      left:  await loadImageTry("mammoth_left.png"),
      right: await loadImageTry("mammoth_right.png"),
    };
    const hunter = {
      up:    await loadImageTry("hunter_up.png"),
      down:  await loadImageTry("hunter_down.png"),
      left:  await loadImageTry("hunter_left.png"),
      right: await loadImageTry("hunter_right.png"),
    };
    const coinImg = await (async () => {
      const img = new Image();
      img.src = "vinecoin.png";
      await img.decode?.().catch(()=>{});
      return img;
    })();
    return { mammoth, hunter, coinImg };
  }

  // -------------------- Audio toggle --------------------
  const bgm = document.getElementById('bgm');
  const toggleBtn = document.getElementById('toggleAudio');
  let musicOn = true;
  toggleBtn.onclick = () => {
    if (musicOn) {
      bgm.pause();
      toggleBtn.textContent = "Music: OFF";
    } else {
      bgm.play().catch(()=>{});
      toggleBtn.textContent = "Music: ON";
    }
    musicOn = !musicOn;
  };

  // -------------------- Canvas / Grid --------------------
  const tile = 20;
  const cols = 20, rows = 20;
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  // 0 = wall, 1 = pellet, 2 = empty
  const tiles = [
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,
    0,1,0,0,1,0,0,1,0,1,0,0,1,0,0,1,0,0,0,0,
    0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
    0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,1,0,0,0,0,
    0,1,1,1,1,0,1,1,0,1,1,0,1,1,1,1,0,0,0,0,
    0,1,0,0,1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,0,
    0,1,0,0,1,0,1,1,1,1,1,0,1,0,0,0,0,0,0,0,
    0,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,0,0,
    0,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,0,0,0,
    0,0,0,0,1,0,1,0,0,0,1,0,1,0,0,1,0,0,0,0,
    0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,
    0,1,0,0,1,0,0,1,0,1,0,0,0,0,0,1,0,0,0,0,
    0,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1,0,0,0,0,
    0,0,1,0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,0,0,
    0,1,1,1,1,0,1,1,0,1,1,0,1,1,1,1,0,0,0,0,
    0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,0,0,0,
    0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  ];

  const idx = (x,y)=> x + y*cols;
  const inBounds = (x,y)=> x>=0 && x<cols && y>=0 && y<rows;
  const isWall = (x,y)=> tiles[idx(x,y)]===0;
  const isPath = (x,y)=> tiles[idx(x,y)]!==0;

  function drawMaze() {
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // draw wall edges only (no solid fill → no blue strip)
    ctx.strokeStyle="#0747ff";
    ctx.lineWidth=4;
    ctx.lineCap="butt";
    ctx.beginPath();

    for (let y=0;y<rows;y++) {
      for (let x=0;x<cols;x++) {
        if (!isWall(x,y)) continue;
        const px=x*tile, py=y*tile;
        if (y>0 && !isWall(x,y-1)) { ctx.moveTo(px,py); ctx.lineTo(px+tile,py); }
        if (y<rows-1 && !isWall(x,y+1)) { ctx.moveTo(px,py+tile); ctx.lineTo(px+tile,py+tile); }
        if (x>0 && !isWall(x-1,y)) { ctx.moveTo(px,py); ctx.lineTo(px,py+tile); }
        if (x<cols-1 && !isWall(x+1,y)) { ctx.moveTo(px+tile,py); ctx.lineTo(px+tile,py+tile); }
      }
    }
    ctx.stroke();

    // draw vinecoins on path tiles (tile==1)
    for (let y=0;y<rows;y++) {
      for (let x=0;x<cols;x++) {
        if (tiles[idx(x,y)]===1) {
          const s = Math.floor(tile*0.6);
          ctx.drawImage(coinImg, x*tile + (tile-s)/2, y*tile + (tile-s)/2, s, s);
        }
      }
    }
  }

  // -------------------- Game actors --------------------
  const DIRS = {
    up:    {x:0,y:-1, key:"ArrowUp"},
    down:  {x:0,y:1,  key:"ArrowDown"},
    left:  {x:-1,y:0, key:"ArrowLeft"},
    right: {x:1,y:0,  key:"ArrowRight"},
  };
  const opposite = (d)=> d==='up'?'down': d==='down'?'up': d==='left'?'right':'left';

  let score=0, lives=3;
  const scoreEl=document.getElementById('score');
  const livesEl=document.getElementById('lives');

  function findCenterSpawn(){
    const cx=Math.floor(cols/2), cy=Math.floor(rows/2);
    let best={x:cx,y:cy,dist:1e9};
    for(let y=1;y<rows-1;y++){
      for(let x=1;x<cols-1;x++){
        if(isPath(x,y)){
          const d=Math.abs(x-cx)+Math.abs(y-cy);
          if(d<best.dist) best={x,y,dist:d};
        }
      }
    }
    return {x:best.x,y:best.y};
  }
  const ghostHouse = findCenterSpawn();

  const startMammoth = { x:9, y:15 };
  let player = { x:startMammoth.x, y:startMammoth.y, dir:'left', next:'left', px:startMammoth.x*tile, py:startMammoth.y*tile };

  function resetPlayer(){
    player.x=startMammoth.x; player.y=startMammoth.y; player.dir='left'; player.next='left';
    player.px=player.x*tile; player.py=player.y*tile;
  }

  const ghosts=[];
  const ghostQueue=[0,1,2,3];
  const ghostSpeed=2;
  function spawnGhost(){
    if(ghosts.length>=4 || ghostQueue.length===0) return;
    const id=ghostQueue.shift();
    ghosts.push({ id, x:ghostHouse.x, y:ghostHouse.y, dir:'left', px:ghostHouse.x*tile, py:ghostHouse.y*tile });
  }
  setTimeout(spawnGhost,1500);
  setTimeout(spawnGhost,3500);
  setTimeout(spawnGhost,5500);
  setTimeout(spawnGhost,7500);

  // Input (also prevent default here)
  window.addEventListener('keydown', e=>{
    e.preventDefault();
    for(const [d,info] of Object.entries(DIRS)){
      if(e.key===info.key) player.next=d;
    }
    if (musicOn) bgm.play().catch(()=>{});
  });

  const atCenter = (px,py)=> (px%tile===0)&&(py%tile===0);
  const canMove = (x,y,dir)=>{
    const nx=x+DIRS[dir].x, ny=y+DIRS[dir].y;
    return inBounds(nx,ny) && isPath(nx,ny);
  };

  const speed=2;
  function stepPlayer(){
    if(atCenter(player.px, player.py)){
      player.x = Math.round(player.px/tile);
      player.y = Math.round(player.py/tile);

      if(canMove(player.x, player.y, player.next)) player.dir = player.next;

      const t = idx(player.x, player.y);
      if(tiles[t]===1){ tiles[t]=2; score++; scoreEl.textContent="Score: "+score; }
    }
    if(atCenter(player.px, player.py) && !canMove(player.x, player.y, player.dir)) return;
    const d=DIRS[player.dir]; player.px += d.x*speed; player.py += d.y*speed;
  }

  function optionsAt(x,y,prevDir){
    if (prevDir && canMove(x,y,prevDir)) return [prevDir]; // keep going if possible
    const opts=[];
    for(const d of ['up','down','left','right']){
      if(d===opposite(prevDir)) continue;
      const nx=x+DIRS[d].x, ny=y+DIRS[d].y;
      if(inBounds(nx,ny) && isPath(nx,ny)) opts.push(d);
    }
    if(opts.length===0 && prevDir) opts.push(opposite(prevDir)); // dead end → backtrack
    return opts;
  }

  function stepGhost(g){
    if(atCenter(g.px,g.py)){
      g.x = Math.round(g.px/tile);
      g.y = Math.round(g.py/tile);

      const opts = optionsAt(g.x,g.y,g.dir);
      if(opts.length===1){
        g.dir = opts[0];
      }else{
        // lightly bias toward player
        let best=opts[0], bestScore=-1e9;
        for(const d of opts){
          const nx=g.x+DIRS[d].x, ny=g.y+DIRS[d].y;
          const score = - (Math.abs(nx-player.x)+Math.abs(ny-player.y)) + Math.random()*0.5;
          if(score>bestScore){ bestScore=score; best=d; }
        }
        g.dir = best;
      }
    }
    if(atCenter(g.px,g.py) && !canMove(g.x,g.y,g.dir)) return;
    const d=DIRS[g.dir]; g.px += d.x*ghostSpeed; g.py += d.y*ghostSpeed;
  }

  function drawMazeAndActors(){
    drawMaze();
    ctx.drawImage(mammoth[player.dir], player.px, player.py, tile, tile);
    for(const g of ghosts){
      ctx.drawImage(hunter[g.dir], g.px, g.py, tile, tile);
    }
  }

  function checkCollisions(){
    for(const g of ghosts){
      const dx=Math.abs((g.px+tile/2)-(player.px+tile/2));
      const dy=Math.abs((g.py+tile/2)-(player.py+tile/2));
      if(dx<tile*0.6 && dy<tile*0.6){
        lives--; livesEl.textContent="Lives: "+lives;
        if(lives<=0){ endGame(false); return; }
        resetPlayer();
        g.x=ghostHouse.x; g.y=ghostHouse.y; g.px=g.x*tile; g.py=g.y*tile; g.dir='left';
      }
    }
  }

  function remainingCoins(){ return tiles.some(v=>v===1); }
  let running=true;
  function endGame(win){
    running=false;
    setTimeout(()=>{ alert((win?"YOU WIN! ":"GAME OVER! ")+"Score: "+score); location.reload(); }, 80);
  }

  // -------------------- Boot --------------------
  let mammoth, hunter, coinImg;
  (async () => {
    ({mammoth, hunter, coinImg} = await loadSprites());
    tiles[idx(ghostHouse.x, ghostHouse.y)] = 2; // no pellet in the house
    resetPlayer();
    if (musicOn) bgm.play().catch(()=>{});
    requestAnimationFrame(function loop(){
      if(!running) return;
      stepPlayer();
      ghosts.forEach(stepGhost);
      checkCollisions();
      drawMazeAndActors();
      if(!remainingCoins()) endGame(true);
      requestAnimationFrame(loop);
    });
  })();
  </script>
</body>
</html>
